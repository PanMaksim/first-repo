#include <iostream>
#include "Header.hpp"

// при подключении через "..." мы пишет что пользователь сам написал, а через <..> встроенные (<> так же читает как встроенные запредкоженые пути)
// если подключинить созданое вручную пользователем через <...> то оно сначала проверит запрекоженые пути а потом начнет искать как созданое пользователем
// при подключении ненужных библиотек мы повышаем время запуска/комплиции файла за счет подключения ненужным файлов/библиотек

//внешняя линковка означает что все файлы видят функцию (любая функция по умолчанию внешняя)
// внутренняя линковка означает что другие файлы не видят эту функцию

// 1-й уровень компиляции - препроцесс, который ищет все вызываемые файлы, а потом уже начинает компиляцию самого кода
// название заголовочного файла при подключении через консоль идет как название файла (включая .cpp/.hpp)
// функция ....
// паралельная компиляция, все отдельно компилируем и потом обьеденяет (повышает скорость компляции)

extern int value; // extern означает что эта переменная уже обьявлена в другом файле (что она глобальная) и её нужно в них найти 
static int value2 = 20; //static означает что это переменная может использоваться только в этом файле 
//при const файла она автоматически стает только для внутренней линковки
//const int* str{ "Hello" };//этот указатель не с внутренней линковкой,  а с внешней (потому что указывает на конскт, но сам указатель не конст)
//const int* const str{ "Hello" };//этот указатель уже с внутренней линковкой
//значит если переменная нужная только в этом файле, но при этом её нужно менять нужно её приписать статик

//в линуксе есть команда size которая напишет розмер всех отдельных частей кода (текст, дата и тд.)
//в системах реального времени (без задержек, например в авиации, тесле) используют статическое виделение памяти (заместо автоматического динамического)


double calc(int a, int b) {
	std::cout << value << std::endl;
	return a + b;
} //если обьявить калк повторно уже в этом файле то оно заберет уже его значение а не с другого файла

struct People {
	//сейчас мы изучаем структуры как PUD (до ориентированого програмирования)
	int age=12;
	const char* name="Jojo";
	size_t id=145;
	////начиная с с++11 можно вводить дефолтные значения
	//int age = 10;
	//const char* name = "Name";
	//size_t id = 100;
	//c точки зрения кода эти переменные не связаны (например они не участвуют в расчете 1 переменной), хотя с точки зрения человека они описывают человека
	//структура - способ именования группы данных которые описывают общий концепт};
	// через структуру мы их обьеденили
	// если бы мы прописали это в мейне было бы тоже самое что мы написали 3 переменные 
	//(но если мы начали бы описывать другого человека пришлось бы снова вводить эти же 3 переменные, но уже с другим именем переменной)
}; 


struct LeadEng {
	People p;
	const char* department;
};

const size_t kCountEmployment{100};
struct Company {
	LeadEng test[kCountEmployment];
};

struct pair {
	bool status;
	size_t res;
};

pair divide(int a, int b) {
	if (b == 0) {
		std::cout << "error";
		return { false, 0 };
	}
	return { true, static_cast <size_t>(a/b)};
}

void move_object(int x, int y, int z) {

}

//void move_object2(Point point) {

//}

struct Point {
	int x;
	int y;
	int z;
};
struct X {
	int x;
};
struct Y {
	int y;

};
struct Z {
	int z;
};
struct Point2 {
	X x;
	Y y;
	Z z;
};

struct Byte {
	char a;
	long int b;
	int c;
};

//@@выравнивание под машинное слово

//struct Byte {
//	char a;
//  int b;
//	int c;
//};

//правильное расположение байтов влияет на розмер байта (из-за кривизны может понадобиться выравнивать структуру), может выдавать разный размер при разном расположении

enum Enum1 {
	FIRST=10,//начальное значение может быть любым и потом +1
	SECOND,
	THIRD
};

const int first{ 0 };
const int second{ 0 };
//если это сделать через енам то память не будет выделяться, а на консты будет

//enum class Error { //енам класс и просто енам программой считываються как разные енумераторы (начиная с с++11 все пишут енам класы, что бы ограничить область видимости)
//	k0k = 0,
//ErrorRegenerate
//};
//enum Error {
//	k0k = 0,
//ErrorRegenerate
//};
//enum Error1{
// k0k =0
//};
//Error connect() {
//
//}


//void case_ (Error::err) {
//	switch (err) {
//		case Error::k0k;
//			break;
//	}
//	default;
//}

int main(int argc, const int** argv) {
	//** означают *[]

	print_path(10); //не обязательно передавать сигнатуру фукнции (сигнатура - что передаеться в функцию)
	//calc(10, 20);  @выдаст ошибку потому что калк использует внутреннюю линковкa
	calc(10, 20);

	//People p; //создали переменную структуры
	//p.age = 10; //1 способ обратиться к переменной через точку
	//p.id = 100;
	//p.name = "Ivo Bobul";
	//std::cout << p.age<<p.id<<p.name << std::endl; //пока что мы не можем выводить сразу весь p

	People p{ 10, "Ivo Bobul", 100 };//второй вариант ввода в структуру через скобки, последовательность ОЧЕНЬ важна
	People* ptr = &p;
	ptr->age = 100; //-> розименовует указатель и указывает на структуру куда он указывает
	// без стрелки пришлось бы писать (*ptr).age

	LeadEng l{{ 10, "Ivo Bobul", 100 } , "AutoMotive"}; //"p" которая находиться в другой структуре не зависит от "p" которая в пипле, нужно снова инициализировать
	std::cout << l.p.age<<l.p.id<<l.p.name<<l.department<<std::endl; //каждый п нужно отдельно выводить

	LeadEng* lptr = &l;
	lptr->p.name; // обратились через следующую структуру к предидущей

	Company company{}; //{} инит через дефолт
	company.test[0].p.age = 100; //записали в масив тест 

	People p1;
	LeadEng l1{ p1, "test" };
	//Company company{ {l1} }; //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	auto pr  = divide(10, 0);
	if (pr.status) { //if pr.statu true
		std::cout << pr.res << std::endl;
		return 0;
	}

	auto [status_div, res_div] = divide(10, 0);// это способ роспаковки, div=bool, res = size_t, компилятор создает новые 2 переменные и связывает их с тем что мы получим на выходе
	//можно заместо переменной написать "_" что будет означать пропуск этой перменной
	//if(auto [status_div, res_div] = divide(10, 0); status_div) // с с++17 появилась возможность писать ";" в иф, и тут эти переменные забудут после иф
	if (pr.status) { //if pr.statu true
		std::cout << pr.res << std::endl;
		return 0;
	} //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	move_object(1, 2, 10); // если количество елементов мого пиши отдельную структуру

	//Point2{};
	//move_object2(X,Y,Z);

	//std::cout << Enum1::FIRST << std::endl;//нужно писать к какому перечислению этот фирст относиться (Enum1::)

	//auto err = connect();
	//Error er{ Error::k0k };
	//int i = Error::k0k;
	//err = Error::k0k;
	//if (err == Error::ErrorRegenerate) {

	//}


	//case_(err);

	return -1;

}
